    private static final String PROP_SHOPPINGLIST_GENERATIONMODE = PropertyHelper
            .getProperty("shoppingList.generationMode");

    private static final String GENERATION_MODE_SIMPLE = "simple";
    private static final String GENERATION_MODE_ADVANCED = "advanced";






        if (PROP_SHOPPINGLIST_GENERATIONMODE.equals("") || PROP_SHOPPINGLIST_GENERATIONMODE
                .equals(GENERATION_MODE_SIMPLE)) {
            // Ermitteln bei welchem Anbieter, welche Konstellationen von Zutaten am günstigsten eingekauft werden
            // können
            Map<AbstractProvider, Set<IngredientQuantity>> bestPriceProviders = determineBestPriceProviders(ingredientQuantities);

            // Erstellen der Einkaufslistenpositionen
            List<ShoppingListItem> shoppingListItems = new ArrayList<ShoppingListItem>();

            for (Entry<AbstractProvider, Set<IngredientQuantity>> entry : bestPriceProviders.entrySet()) {

                for (IngredientQuantity ingredientQuantity : entry.getValue()) {
                    shoppingListItems.add(createShoppingListItem(entry.getKey(), ingredientQuantity));
                }
            }

            if (!shoppingListItems.isEmpty()) {
                result.setShoppingListItems(shoppingListItems);
            }
        }
        else if (PROP_SHOPPINGLIST_GENERATIONMODE.equals(GENERATION_MODE_ADVANCED)) {
            result = determineBestPriceShoppingList(ingredientQuantities);
        }



   /**
     * 
     * @param ingredientQuantities
     * @return
     */
    private ShoppingList determineBestPriceShoppingList(Map<Ingredient, Amount> ingredientQuantities) {
        List<ShoppingList> shoppingLists = new ArrayList<ShoppingList>();

        Map<Ingredient, Set<Set<ShoppingListItem>>> ingredientShoppingListItems = new HashMap<Ingredient, Set<Set<ShoppingListItem>>>();

        Set<Set<ShoppingListItem>> all = new HashSet<Set<ShoppingListItem>>();

        Map<Set<ShoppingList>, Set<Set<ShoppingListItem>>> graph2 = new HashMap<Set<ShoppingList>, Set<Set<ShoppingListItem>>>();

        for (Entry<Ingredient, Amount> entry : ingredientQuantities.entrySet()) {

            Ingredient ingredient = entry.getKey();
            Amount quantity = entry.getValue();

            Set<Set<ShoppingListItem>> distributedIngredientQuantityOfProviders = distributeQuantityOfIngredientToProviders(
                    ingredient, quantity);

            all.addAll(distributedIngredientQuantityOfProviders);

            ingredientShoppingListItems.put(ingredient, distributedIngredientQuantityOfProviders);

            System.out.println(distributedIngredientQuantityOfProviders.size());

        }

        for (Entry<Ingredient, Set<Set<ShoppingListItem>>> entry : ingredientShoppingListItems.entrySet()) {

            for (Set<ShoppingListItem> set : entry.getValue()) {

                fillGraph(graph2, entry, set, ingredientShoppingListItems);

            }
        }

        for (Entry<Ingredient, Set<Set<ShoppingListItem>>> entry : ingredientShoppingListItems.entrySet()) {

            for (Set<ShoppingListItem> set : entry.getValue()) {

                Set<Entry<Ingredient, Set<Set<ShoppingListItem>>>> entrySet = new HashSet<Entry<Ingredient, Set<Set<ShoppingListItem>>>>(
                        ingredientShoppingListItems.entrySet());

                entrySet.remove(entry);

                for (Entry<Ingredient, Set<Set<ShoppingListItem>>> innerEntry : entrySet) {

                    for (Set<ShoppingListItem> test : innerEntry.getValue()) {

                        ShoppingList tempShoppingList = new ShoppingList();

                        tempShoppingList.setShoppingListItems(new ArrayList<ShoppingListItem>(set));

                        for (ShoppingListItem item : test) {

                            tempShoppingList.getShoppingListItems().add(item);
                        }

                    }
                }

            }

        }

        // Sortierung der temporären Einkaufslisten nach dem besten (günstigsten) Preis
        Collections.sort(shoppingLists, new Comparator<ShoppingList>() {

            @Override
            public int compare(ShoppingList sl1, ShoppingList sl2) {
                return sl1.calculateTotalPrice().compareTo(sl2.calculateTotalPrice());
            }
        });

        return shoppingLists.iterator().next();
    }
    
    
    
    
      private void fillGraph(Map<Set<ShoppingList>, Set<Set<ShoppingListItem>>> graph2,
            Entry<Ingredient, Set<Set<ShoppingListItem>>> entry, Set<ShoppingListItem> set,
            Map<Ingredient, Set<Set<ShoppingListItem>>> ingredientShoppingListItems) {
        // TODO(tsahling) provide sensible implementation

        // Set<Entry<Ingredient, Set<Set<ShoppingListItem>>>> entrySet = new HashSet<Entry<Ingredient,
        // Set<Set<ShoppingListItem>>>>(
        // ingredientShoppingListItems.entrySet());
        //
        // entrySet.remove(entry);
        //
        //
        //
        // for (Entry<Ingredient, Set<Set<ShoppingListItem>>> newEntry : ingredientShoppingListItems.entrySet()) {
        //
        // for (Set<ShoppingListItem> newSet : entry.getValue()) {
        //
        // if(graph2.containsKey(set)) {
        // graph2.get(set).addAll((Sets.newHashSet(newSet));
        // } else {
        // graph2.put(set, newSet);
        // }
        //
        //
        //
        //
        // }
        // }
        //
        // fillGraph(graph2, entry, set, entrySet);
        //
    }

    /**
     * Methode um die benötigte {@link Amount} einer {@link Ingredient} in allen Konstellationen auf die
     * {@link AbstractProvider} zu verteilen, bei denen die {@link Ingredient} beschaffbar ist.
     * 
     * @param ingredient
     * @param quantity
     * @return
     */
    private Set<Set<ShoppingListItem>> distributeQuantityOfIngredientToProviders(Ingredient ingredient, Amount quantity) {

        Set<Set<ShoppingListItem>> result = new LinkedHashSet<Set<ShoppingListItem>>();

        // Sucht alle Anbieter bei denen die Zutat beschaffbar ist
        Set<AbstractProvider> ingredientProviders = providerBase.findProvidersByIngredient(ingredient);

        // Erstellt alle möglichen Anbieterkombinationen
        List<List<AbstractProvider>> ingredientProviderCombinations = createIngredientProviderCombinations(ingredientProviders);

        if (ingredientProviderCombinations != null && !ingredientProviderCombinations.isEmpty()) {

            for (List<AbstractProvider> ingredientProviderCombination : ingredientProviderCombinations) {

                Set<ShoppingListItem> shoppingListItems = new LinkedHashSet<ShoppingListItem>();

                if (ingredientProviderCombination.size() == 1) {

                    AbstractProvider provider = ingredientProviderCombination.iterator().next();

                    // Nur wenn bei einem einzelnen Anbieter die Zutat vollständig beschaffbar ist, kommt dieser in das
                    // Ergebnis.
                    if (provider.hasIngredientWithQuantity(ingredient, quantity)) {
                        Amount quantityToOrder = provider.calculateQuantityFromIngredientAndQuantity(ingredient,
                                quantity);
                        // Fügt eine temporäre Einkaufslistenposition in ein Kombinationsset ein
                        shoppingListItems.add(createTempShoppingListItem(ingredient, quantityToOrder, provider));
                        // Fügt das Kombinationsset in das Ergebnis ein
                        result.add(shoppingListItems);
                    }
                }
                else {
                    Amount quantityToDistribute = new Amount(quantity);

                    Amount quantityToDistributeForEachProvider = new Amount(NumberHelper.divide(quantity.getValue(),
                            BigDecimal.valueOf(ingredientProviderCombination.size()), 0, RoundingMode.HALF_UP),
                            quantity.getUnit());

                    if (haveProvidersQuantityToDistribute(ingredientProviderCombination, ingredient,
                            quantityToDistributeForEachProvider)) {

                        for (AbstractProvider provider : ingredientProviderCombination) {
                            // Sucht die Menge einer Zutat von einem Anbieter
                            Amount ingredientProviderQuantity = provider.calculateQuantityFromIngredientAndQuantity(
                                    ingredient, quantityToDistributeForEachProvider);
                            // Fügt eine temporäre Einkaufslistenposition in ein Kombinationsset ein
                            shoppingListItems.add(createTempShoppingListItem(ingredient, ingredientProviderQuantity,
                                    provider));
                            // Subtrahiert von der Gesamtmenge der Zutat die Menge der Zutat des Anbieters ab
                            quantityToDistribute = new Amount(quantityToDistribute)
                                    .subtract(ingredientProviderQuantity);
                        }
                    }
                    else {
                        boolean bla = true;

                        if (bla) {

                        }
                    }

                    // Fügt das Kombinationsset in das Ergebnis ein
                    result.add(shoppingListItems);
                }
            }
        }

        return result;
    }

    /**
     * Methode zum Erstellen aller möglichen Anbieterkombinationen auf Basis der übergebenen {@link AbstractProvider}.
     * 
     * Als erstes wird mit Hilfe der Google Guava Library ein PowerSet erstellt, welches alle möglichen Kombinationen
     * der
     * übergebenen {@link AbstractProvider} enthält.
     * 
     * Beispiel: ImmutableSet.of(1, 2) => {{}, {1}, {2}, {1, 2}}
     * 
     * Danach wird der leere Eintrag aus dem PowerSet entfernt, da dieser später nicht mehr benötigt wird.
     * 
     * Enthält ein Subset des PowerSet mehr als einen Eintrag, müssen alle Permutationen des Subsets zusätzlich mit
     * Hilfe Google Guava Library erstellt werden und im Ergebnis gespeichert werden. Die Aufteilung einer
     * {@link Ingredient} müssen passieren, da diese abhängig ist von der Reihenfolge der {@link AbstractProvider} und
     * der Verfügbarkeit der {@link Ingredient}.
     * 
     * @param ingredientProviders Das Set mit übergebenen {@link AbstractProvider}
     * @return Eine Liste von Listen mit allen Kombinationen von {@link AbstractProvider}
     */
    private List<List<AbstractProvider>> createIngredientProviderCombinations(Set<AbstractProvider> ingredientProviders) {
        List<List<AbstractProvider>> result = new LinkedList<List<AbstractProvider>>();

        if (ingredientProviders != null && !ingredientProviders.isEmpty()) {
            // Erstellung des PowerSet mit allen Anbieterkombinationen
            Set<Set<AbstractProvider>> powerSet = Sets.powerSet(ingredientProviders);

            for (Set<AbstractProvider> providers : powerSet) {

                if (!providers.isEmpty()) {

                    if (providers.size() == 1) {
                        result.add(Lists.newLinkedList(providers));
                    }
                    else {
                        // Erstellen aller Permutationen (Anordnungsmöglichkeiten) der Anbieter
                        Collection<List<AbstractProvider>> permutations = Collections2.permutations(providers);

                        for (List<AbstractProvider> perm : permutations) {
                            if (!perm.isEmpty()) {
                                result.add(Lists.newLinkedList(perm));
                            }
                        }
                    }
                }
            }
        }

        return result;
    }

    /**
     * 
     * @param providers
     * @param ingredient
     * @param quantityToDistribute
     * @return
     */
    private boolean haveProvidersQuantityToDistribute(List<AbstractProvider> providers, Ingredient ingredient,
            Amount quantityToDistribute) {

        for (AbstractProvider provider : providers) {

            if (!provider.hasIngredientWithQuantity(ingredient, quantityToDistribute)) {
                return false;
            }
        }

        return true;
    }
    
    
    
    
    
      /**
     * Methode um mehrere {@link AbstractProvider} mit einer {@link Amount} ins Ergebnis zu übernehmen.
     * 
     * @param result
     * @param providers
     * @param quantity
     */
    private void putProvidersWithQuantityToResultMap(Map<AbstractProvider, List<Amount>> result,
            Set<AbstractProvider> providers, Amount quantity) {

        if (providers != null && !providers.isEmpty()) {

            for (AbstractProvider provider : providers) {
                putToResultMap(result, provider, quantity);
            }
        }
    }

    /**
     * Methode um die letzte {@link Amount} der übergebenen {@link AbstractProvider} zu entfernen.
     * 
     * @param result
     * @param providers
     */
    private void removeLastQuantityFromResultMap(Map<AbstractProvider, List<Amount>> result,
            List<AbstractProvider> providers) {

        if (result != null && !result.isEmpty() && providers != null && !providers.isEmpty()) {

            for (Entry<AbstractProvider, List<Amount>> entry : result.entrySet()) {

                if (providers.contains(entry.getKey())) {
                    Amount lastQuantity = (Amount) ((LinkedList<Amount>) entry.getValue()).getLast();
                    entry.getValue().remove(lastQuantity);
                }
            }
        }
    }

    /**
     * 
     * @param ingredient
     * @param quantity
     * @param provider
     * @return
     */
    private ShoppingListItem createTempShoppingListItem(Ingredient ingredient, Amount quantity,
            AbstractProvider provider) {
        return new ShoppingListItem(ingredient, quantity, provider);
    }
    
    
        /**
     * Methode um einen {@link AbstractProvider} und einen {@link Amount} ins Ergebnis zu übernehmen.
     * 
     * @param result
     * @param key
     * @param value
     */
    private void putToResultMap(Map<AbstractProvider, List<Amount>> result, AbstractProvider key, Amount value) {
        if (result.containsKey(key)) {
            result.get(key).add(new Amount(value));
        }
        else {
            result.put(key, Lists.newLinkedList(Arrays.asList(new Amount(value))));
        }
    }
    
    
    
        /**
     * 
     * @param value1
     * @param value2
     * @param scale
     * @param roundingMode
     * @return
     */
    public static BigDecimal divide(BigDecimal value1, BigDecimal value2, int scale, RoundingMode roundingMode) {
        return value1.divide(value2, scale, roundingMode);
    }
    
    
    # Einkaufsliste
shoppingList.generationMode=simple

        // if (providerGraph != null && !providerGraph.isEmpty()) {
        //
        // for (Entry<AbstractProvider, Set<Set<AbstractProvider>>> entry : providerGraph.entrySet()) {
        //
        // AbstractProvider provider = entry.getKey();
        // Set<Set<AbstractProvider>> otherProviders = entry.getValue();
        //
        // Amount providerIngredientQuantity = provider.findQuantityByIngredient(ingredient);
        //
        // // Zutat ist nur bei einem Anbieter vorrätig, dementsprechend wird die verfügbare oder benötigte Menge
        // // ins Ergebnis übernommen
        // if (otherProviders.isEmpty()) {
        //
        // Amount orderableQuantity = null;
        //
        // if (provider.hasIngredientWithQuantity(ingredient, quantity)) {
        // orderableQuantity = quantity;
        // }
        // else {
        // orderableQuantity = providerIngredientQuantity;
        // }
        //
        // putToResultMap(result, provider, orderableQuantity);
        // }
        // // Zutat ist bei mehreren Anbietern vorrätig, dementsprechend wird die benötigte Menge in allen
        // // Kombinationen auf die Anbieter verteilt
        // else {
        //
        // Amount quantityMinusProviderQuantity = new Amount(quantity).subtract(providerIngredientQuantity);
        // Amount quantityToDistribute;
        //
        // // Zutat ist bei Anbieter vollständig bestellbar
        // if (!NumberHelper.compareGreaterOrEqual(quantityMinusProviderQuantity.getValue(), BigDecimal.ZERO)) {
        // quantityToDistribute = new Amount(quantity).subtract(quantity);
        // putToResultMap(result, provider, quantity);
        // }
        // else {
        // quantityToDistribute = new Amount(quantityMinusProviderQuantity);
        // putToResultMap(result, provider, providerIngredientQuantity);
        // }
        //
        // for (Set<AbstractProvider> outerOtherProviders : otherProviders) {
        //
        // for (AbstractProvider otherProvider : outerOtherProviders) {
        //
        // Amount otherProviderIngredientQuantity = otherProvider.findQuantityByIngredient(ingredient);
        //
        // Amount quantityToDistributeMinusOtherProviderQuantity = new Amount(quantityToDistribute)
        // .subtract(otherProviderIngredientQuantity);
        //
        // // Zutat ist bei Anbieter vollständig bestellbar
        // if (!NumberHelper.compareGreaterOrEqual(
        // quantityToDistributeMinusOtherProviderQuantity.getValue(), BigDecimal.ZERO)) {
        // putToResultMap(result, otherProvider, quantityToDistribute);
        // quantityToDistribute.subtract(quantityToDistribute);
        // }
        // else {
        // putToResultMap(result, otherProvider, otherProviderIngredientQuantity);
        // quantityToDistribute.subtract(otherProviderIngredientQuantity);
        // }
        //
        // // if (!NumberHelper.compareGreater(quantityToDistribute.getValue(), BigDecimal.ZERO)) {
        // // break;
        // // }
        // }
        // }
        //
        // //
        // // // while (NumberHelper.compareGreater(quantityToDistribute.getValue(), BigDecimal.ZERO)) {
        // // //
        // // //
        // // //
        // // // Amount test = quantityToDistribute.subtract(otherProviderIngredientQuantity);
        // // //
        // // // }
        // //
        // // }
        // }
        // }
        // }

















            // for (Entry<Ingredient, Amount> entry : ingredientQuantities.entrySet()) {
        //
        // // Sucht alle Anbieter, die die Zutat vorrätig haben
        // Set<AbstractProvider> providersWithIngredient = providerBase.findProvidersByIngredient(entry.getKey());
        //
        // // Ein Anbieter hat die Zutat vorrätig
        // if (providersWithIngredient.size() == 1) {
        //
        // AbstractProvider provider = providersWithIngredient.iterator().next();
        //
        // // Überprüfen ob Anbieter die Zutat in gewünschter Menge hat
        // if (provider.hasIngredientWithQuantity(entry.getKey(), entry.getValue())) {
        // // Wenn Anbieter die Zutat in gewünschter Menge vorrätig hat, muss diese unabhängig vom Preis bei
        // // ihm gekauft werden, da er der einzige Anbieter der Zutat ist
        // addIngredientAndQuantity(result, provider, entry.getKey(), entry.getValue());
        // }
        // }
        // // Mehrere Anbieter haben die Zutat vorrätig
        // else if (providersWithIngredient.size() > 1) {
        //
        // for (AbstractProvider provider : providersWithIngredient) {
        // PriceListItem priceListItem = provider.findPriceListItemForIngredient(entry.getKey());
        //
        // IngredientQuantity ingredientQuantity = new IngredientQuantity(priceListItem.getIngredient(),
        // priceListItem.getSize());
        //
        // if (test.containsKey(provider)) {
        // test.get(provider).add(ingredientQuantity);
        // }
        // else {
        // test.put(provider, new HashSet<IngredientQuantity>(Arrays.asList(ingredientQuantity)));
        // }
        // }
        //
        // }
        // }
        //
        // System.out.println(ingredientQuantities.size());
        //
        // if (test != null && !test.isEmpty()) {
        // boolean foo = true;
        //
        // }

        // int size = ingredientQuantities.size();
        //
        //
        //
        // Map<Ingredient, Map<AbstractProvider, PriceListItem>> test = new HashMap<Ingredient, Map<AbstractProvider,
        // PriceListItem>>();
        //
        // for (Ingredient ingredient : ingredientQuantities.keySet()) {
        //
        // if(!test.containsKey(ingredient)) {
        // test.put(ingredient, new HashMap<AbstractProvider, PriceListItem>());
        // }
        //
        // Set<AbstractProvider> providers = providerBase.findProvidersByIngredient(ingredient);
        //
        //
        // for(AbstractProvider provider : providers) {
        //
        //
        //
        // if(test.get(ingredient).containsKey(provider)) {
        //
        // } else {
        //
        // provider.getIngredientWithQuantity()
        //
        // test.get(ingredient).put(provider, )
        // }
        // }
        // }
        //
        // for (Entry<Ingredient, Amount> entry : ingredientQuantities.entrySet()) {
        //
        // AbstractProvider provider = providerBase.findBestPriceProviderByIngredient(entry.getKey());
        //
        // }
        //
        // // TODO (Tim Sahling) Hier den neuen Algorithmus aus Scan umsetzen
        // List<BestPriceProvider> bestPriceProviders = new ArrayList<BestPriceProvider>();
        //
        // for (Ingredient ingredient : ingredientQuantities.keySet()) {
        // AbstractProvider provider = providerBase.findBestPriceProviderByIngredient(ingredient);
        //
        // BestPriceProvider bestPriceProvider = new BestPriceProvider(provider);
        //
        // if (bestPriceProviders.contains(bestPriceProvider)) {
        // increaseBestPriceCounter(bestPriceProviders, bestPriceProvider);
        // }
        // else {
        // bestPriceProviders.add(bestPriceProvider);
        // }
        // }
        //
        // Collections.sort(bestPriceProviders, bestPriceProviderSorter);
        //
    
    
        private static final class QuantityPrice {
        private Amount quantity;
        private Amount price;

    }

    private BestPriceProviderSorter bestPriceProviderSorter = new BestPriceProviderSorter();


    private static final class BestPriceProvider {
        private AbstractProvider provider;
        private Integer bestPriceCounter;

        public BestPriceProvider(AbstractProvider provider) {
            this.provider = provider;
            this.bestPriceCounter = Integer.valueOf(1);
        }

        public AbstractProvider getProvider() {
            return provider;
        }

        public void setProvider(AbstractProvider provider) {
            this.provider = provider;
        }

        public Integer getBestPriceCounter() {
            return bestPriceCounter;
        }

        public void setBestPriceCounter(Integer bestPriceCounter) {
            this.bestPriceCounter = bestPriceCounter;
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + ((provider == null) ? 0 : provider.hashCode());
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            BestPriceProvider other = (BestPriceProvider) obj;
            if (provider == null) {
                if (other.provider != null)
                    return false;
            }
            else if (!provider.equals(other.provider))
                return false;
            return true;
        }

        @Override
        public String toString() {
            return "BestPriceProvider [provider=" + provider + ", bestPriceCounter=" + bestPriceCounter + "]";
        }
    }
    
    private static final class BestPriceProviderSorter implements Comparator<BestPriceProvider> {

        @Override
        public int compare(BestPriceProvider arg0, BestPriceProvider arg1) {
            return arg1.getBestPriceCounter().compareTo(arg0.getBestPriceCounter());
        }

    }

    private void increaseBestPriceCounter(List<BestPriceProvider> bestPriceProviders, BestPriceProvider provider) {
        for (BestPriceProvider bestPriceProvider : bestPriceProviders) {
            if (bestPriceProvider.equals(provider)) {
                bestPriceProvider.setBestPriceCounter(bestPriceProvider.getBestPriceCounter() + 1);
            }
        }
    }
    
    /**
     * Erstellt einen Anbieter.
     * 
     * @param provider
     *            Der zu erstellende Anbieter
     * @return Der erstellte Anbieter
     */
    protected abstract AbstractProvider createProvider(AbstractProvider provider);

    /**
     * Bearbeitet einen Anbieter.
     * 
     * @param provider
     *            Der zu bearbeitende Anbieter
     * @return Der bearbeitete Anbieter
     */
    protected abstract AbstractProvider updateProvider(AbstractProvider provider);

    /**
     * Löscht einen Anbieter.
     * 
     * @param provider
     *            Der zu löschende Anbieter
     */
    protected abstract void deleteProvider(AbstractProvider provider);
    
    
    
                // Sucht alle Anbieter, die die Zutat vorrätig haben
            Set<AbstractProvider> providersWithIngredient = providerBase.findProvidersByIngredient(entry.getKey());

            // Ein Anbieter hat die Zutat vorrätig
            if (providersWithIngredient.size() == 1) {

                AbstractProvider provider = providersWithIngredient.iterator().next();

                // Überprüfen ob Anbieter die Zutat in gewünschter Menge hat
                if (provider.hasIngredientWithQuantity(entry.getKey(), entry.getValue())) {
                    // Wenn Anbieter die Zutat in gewünschter Menge vorrätig hat, muss diese unabhängig vom Preis bei
                    // ihm gekauft werden, da er der einzige Anbieter der Zutat ist
                    addIngredientAndQuantity(result, provider, entry.getKey(), entry.getValue());
                }
            }
            // Mehrere Anbieter haben die Zutat vorrätig
            else if (providersWithIngredient.size() > 1) {
      
                IngredientQuantity ingredientQuantity = new IngredientQuantity(entry.getKey(), entry.getValue());

                if (test.containsKey(ingredientQuantity)) {
                    test.get(ingredientQuantity).addAll(providersWithIngredient);
                }
                else {
                    test.put(ingredientQuantity, providersWithIngredient);
                }
            }
            
            
                  if (test != null && !test.isEmpty()) {

            for (Entry<IngredientQuantity, Set<AbstractProvider>> entry : test.entrySet()) {

                System.out.println(entry.getKey());
                System.out.println(entry.getValue());
            }

        }